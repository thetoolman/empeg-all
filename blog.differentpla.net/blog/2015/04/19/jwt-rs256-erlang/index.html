<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width initial-scale=1" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Validating RS256-signed JSON Web Tokens in Erlang</title>
<meta name="description" content="Jekyll sources for blog.differentpla.net">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"> 
<!-- theme is https://bootswatch.com/yeti/ -->
<link rel="stylesheet" href="../../../../../css/yeti/bootstrap.min.css">
<link rel="stylesheet" href="../../../../../css/yeti-custom.css">
<link rel="stylesheet" href="../../../../../css/site.css">

<link rel="canonical" href="index.html">
<link type="application/atom+xml" rel="alternate" href="../../../../../feed.xml" title="Roger's Blog" />
</head>


<body>

<div class="navbar navbar-inverse" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <ul class="nav navbar-nav navbar-left">
                <li><a class="navbar-brand" href="../../../../../index.html">Roger's Blog</a></li>
            </ul>
        </div>
    </div>
</div>



<div class="container">
    <article>
    <h1>Validating RS256-signed JSON Web Tokens in Erlang</h1>
    <div class="details">
        <span class="created_at timeago" title="2015-04-19 14:29:00 +0000">2015-04-19 14:29:00 +0000</span>
        
        <span class="label label-default"><a href="../../../../../tag/jwt">jwt</a></span>
        
        <span class="label label-default"><a href="../../../../../tag/erlang">erlang</a></span>
        
    </div>
    <p></p>
    <p>I’m currently playing with OpenID Connect (OAuth 2.0 for Login), to allow
people to log into a web site using their Google account. The web site is built
using Erlang.</p>

<p>By following the <a href="https://developers.google.com/identity/protocols/OpenIDConnect">Google
documentation</a>,
I’ve managed to send an authentication request to Google, exchange the code
returned for an ID token, and extract the user information from the ID token.</p>

<p>The documentation says:</p>

<blockquote>
  <p>since you are communicating directly with Google over an intermediary-free
HTTPS channel and using your client secret to authenticate yourself to
Google, you can be confident that the token you receive really comes from
Google and is valid.</p>
</blockquote>

<p>However, I wanted to deal with the token validation as well. Sample code for
C#, Java, Ruby etc. exists, but I couldn’t find anything for Erlang, so…</p>

<h2 id="id-token">ID Token</h2>

<p>If you use Google OpenID Connect, you get back an <code class="highlighter-rouge">id_token</code> that looks
something like <code class="highlighter-rouge">eyJh</code>…<code class="highlighter-rouge">MifQ.eyJp</code>…<code class="highlighter-rouge">MzR9.rG-s</code>…<code class="highlighter-rouge">btCc</code>.</p>

<p>This is a <a href="http://blog.differentpla.net/blog/2015/04/19/jwt-rs256-erlang/see&#32;http://jwt.io/">JSON Web Token (JWT)</a>.</p>

<p>It’s in three parts (header, payload and signature), separated by dots. Each
part is base64url-encoded. Erlang doesn’t have a built-in base64url module, so
you’ll have to <a href="https://github.com/dvv/base64url">find one</a>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[H, P, S] = binary:split(Token, &lt;&lt;"."&gt;&gt;, [global]).
Header = jiffy:decode(base64url:decode(H), [return_maps]).
Payload = jiffy:decode(base64url:decode(P), [return_maps]).
Signature = base64url:decode(S).
</code></pre></div></div>

<h2 id="key-id">Key ID</h2>

<p>The header is JSON, and looks something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "alg": "RS256",
  "kid": "8faca3e0eff37d416d0a8a9770d8f09c7eeffce3"
}
</code></pre></div></div>

<p>The signing algorithm is given is given in the header as <code class="highlighter-rouge">RS256</code>, which is “RSA
using SHA-256 hash algorithm”. The particular certificate to be used is
specified by the <code class="highlighter-rouge">kid</code> field.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#{&lt;&lt;"kid"&gt;&gt; := KId} = Header.
</code></pre></div></div>

<h2 id="googles-openid-configuration">Google’s OpenID Configuration</h2>

<p>To find Google’s JWT signing certificates, we first need to get the Discovery document for Google’s OpenID Connect service, which is at <code class="highlighter-rouge">https://accounts.google.com/.well-known/openid-configuration</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ok, _} = application:ensure_all_started(inets).
{ok, _} = application:ensure_all_started(ssl).

ConfigurationUrl =
    "https://accounts.google.com/.well-known/openid-configuration".
{ok, { {_, 200, _}, _, ConfigurationJson}} =
    httpc:request(ConfigurationUrl).
Configuration = jiffy:decode(ConfigurationJson, [return_maps]).
</code></pre></div></div>

<h2 id="google-signing-keys">Google Signing Keys</h2>

<p>The discovery document contains a field <code class="highlighter-rouge">jwks_uri</code> which points to the JWT signing keys:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#{&lt;&lt;"jwks_uri"&gt;&gt; := JwksUri} = Configuration.
</code></pre></div></div>

<p>And we can go and get that document:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ok, { {_, 200, _}, _, JwksJson}} =
    httpc:request(binary_to_list(JwksUri)).
</code></pre></div></div>

<p>This returns a JSON object that looks like the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "keys": [
    {
      "kty": "RSA", "alg": "RS256", "use": "sig",
      "kid": "8faca3e0eff37d416d0a8a9770d8f09c7eeffce3",
      "n": "xJiA...5Kik", "e": "AQAB"
    },

    ...
  ]
}
</code></pre></div></div>

<p>The real document has more than one key in it. You should look up the entry
where the <code class="highlighter-rouge">kid</code> field matches the one specified in the token.</p>

<p>According to the Google documentation, we should cache this document. The
<code class="highlighter-rouge">Cache-Control</code> and <code class="highlighter-rouge">Expires</code> HTTP headers appear to be set appropriately for
this.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Jwks = jiffy:decode(JwksJson, [return_maps]).
#{&lt;&lt;"keys"&gt;&gt; := Keys} = Jwks.
[Key] = lists:filter(
            fun(Key) -&gt;
                #{&lt;&lt;"kid"&gt;&gt; := K} = Key,
                K =:= KId
            end, Keys).
</code></pre></div></div>

<h2 id="public-key-modulus-and-exponent">Public Key Modulus and Exponent</h2>

<p>We need the public key modulus and exponent, which are <code class="highlighter-rouge">n</code> and <code class="highlighter-rouge">e</code>
respectively. They’re base64url-encoded, and we want them as integers, so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#{&lt;&lt;"n"&gt;&gt; := N0, &lt;&lt;"e"&gt;&gt; := E0} = Key.
N1 = base64url:decode(N0).
E1 = base64url:decode(E0).
N = binary:decode_unsigned(N1).
E = binary:decode_unsigned(E1).
</code></pre></div></div>

<h2 id="validating-the-signature">Validating the signature</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Msg = iolist_to_binary([H, &lt;&lt;"."&gt;&gt;, P]),
IsValid = crypto:verify(rsa, sha256, Msg, Signature, [E, N]).
</code></pre></div></div>

<h2 id="done">Done?</h2>

<p>Not quite. The <a href="https://developers.google.com/identity/protocols/OpenIDConnect#validatinganidtoken">documentation</a> requires 5 steps:</p>

<ol>
  <li>Verify that the ID token is a JWT which is properly signed with an
appropriate Google public key.</li>
  <li>Verify that the value of aud in the ID token is equal to your app’s client
ID.</li>
  <li>Verify that the value of iss in the ID token is equal to accounts.google.com
or https://accounts.google.com.</li>
  <li>Verify that the expiry time (exp) of the ID token has not passed.</li>
  <li>If you passed a hd parameter in the request, verify that the ID token has a
hd claim that matches your Google Apps hosted domain.</li>
</ol>

<p>We’ve only done the first step, but it is the hardest. The others are left as an
exercise for the reader.</p>

</article>

</div>

<script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.4.0/jquery.timeago.min.js"></script>

<script type="text/javascript">
$(document).ready(function() {
        $('.timeago').timeago();
        $('div.body > h1, h2, h3, h4, h5, h6').each(function(i) {
            $(this).append(
            '<a class="anchorlink" title="Link to ' +
                $(this).text() + '" href="index.html#' + $(this).attr('id') + '"></a>');
            });
        });
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40120477-1', 'auto');
  ga('send', 'pageview');

</script>
</body>

</html>
